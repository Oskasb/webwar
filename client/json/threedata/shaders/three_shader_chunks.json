[
  {
    "SHADER_CHUNKS": {
      "LOAD_CHUNK_INDEX":[
        "SPE_CHUNKS",
        "INSTANCING_CHUNKS"
      ],
      "SPE_CHUNKS":{
        "enterVoidMain":["void main(){"],
        "exitVoidMain":["}"],
        "defines":[
          " #define PACKED_COLOR_SIZE 256.0",
          " #define PACKED_COLOR_DIVISOR 255.0",
          ""
        ],
        "uniforms": [
          "uniform float deltaTime;",
          "uniform float runTime;",
          "uniform sampler2D texture;",
          "uniform vec4 textureAnimation;",
          "uniform float scale;",
          ""
        ],
        "attributes": [
          "attribute vec4 acceleration;",
          "attribute vec3 velocity;",
          "attribute vec4 rotation;",
          "attribute vec3 rotationCenter;",
          "attribute vec4 params;",
          "attribute vec4 size;",
          "attribute vec4 angle;",
          "attribute vec4 color;",
          "attribute vec4 opacity;",
          ""
        ],

        "varying": [
          "varying vec4 vColor;",
          " #ifdef SHOULD_ROTATE_TEXTURE",
          "    varying float vAngle;",
          " #endif ",

          " #ifdef SHOULD_CALCULATE_SPRITE",
          "    varying vec4 vSpriteSheet;",
          " #endif ",
          ""
        ],

        "outgoingLight": [
          "    outgoingLight = vColor.xyz * rotatedTexture.xyz;",
          "    gl_FragColor = vec4( outgoingLight.xyz, rotatedTexture.w * vColor.w );",
          ""
        ],

        "branchAvoidanceFunctions": [
          "float when_gt(float x, float y) {",
          "    return max(sign(x - y), 0.0);",
          "}",

          "float when_lt(float x, float y) {",
          "    return min( max(1.0 - sign(x - y), 0.0), 1.0 );",
          "}",

          "float when_eq( float x, float y ) {",
          "    return 1.0 - abs( sign( x - y ) );",
          "}",

          "float when_ge(float x, float y) {",
          "  return 1.0 - when_lt(x, y);",
          "}",

          "float when_le(float x, float y) {",
          "  return 1.0 - when_gt(x, y);",
          "}",

          "float and(float a, float b) {",
          "    return a * b;",
          "}",

          "float or(float a, float b) {",
          "    return min(a + b, 1.0);",
          "}",
          ""
        ],
        "unpackColor": [
          "vec3 unpackColor( in float hex ) {",
          "   vec3 c = vec3( 0.0 );",

          "   float r = mod( (hex / PACKED_COLOR_SIZE / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );",
          "   float g = mod( (hex / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );",
          "   float b = mod( hex, PACKED_COLOR_SIZE );",

          "   c.r = r / PACKED_COLOR_DIVISOR;",
          "   c.g = g / PACKED_COLOR_DIVISOR;",
          "   c.b = b / PACKED_COLOR_DIVISOR;",

          "   return c;",
          "}",
          ""
        ],

        "unpackRotationAxis": [
          "vec3 unpackRotationAxis( in float hex ) {",
          "   vec3 c = vec3( 0.0 );",

          "   float r = mod( (hex / PACKED_COLOR_SIZE / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );",
          "   float g = mod( (hex / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );",
          "   float b = mod( hex, PACKED_COLOR_SIZE );",

          "   c.r = r / PACKED_COLOR_DIVISOR;",
          "   c.g = g / PACKED_COLOR_DIVISOR;",
          "   c.b = b / PACKED_COLOR_DIVISOR;",

          "   c *= vec3( 2.0 );",
          "   c -= vec3( 1.0 );",

          "   return c;",
          "}",
          ""
        ],
        "floatOverLifetime": [
          "float getFloatOverLifetime( in float positionInTime, in vec4 attr ) {",
          "    highp float value = 0.0;",
          "    float deltaAge = positionInTime * float( 4 - 1 );",
          "    float fIndex = 0.0;",
          "    float shouldApplyValue = 0.0;",
          "    value += attr[ 0 ] * when_eq( deltaAge, 0.0 );",
          "",
          "    for( int i = 0; i < 4 - 1; ++i ) {",
          "       fIndex = float( i );",
          "       shouldApplyValue = and( when_gt( deltaAge, fIndex ), when_le( deltaAge, fIndex + 1.0 ) );",
          "       value += shouldApplyValue * mix( attr[ i ], attr[ i + 1 ], deltaAge - fIndex );",
          "    }",
          "",
          "    return value;",
          "}",
          ""
        ],
        "colorOverLifetime": [
          "vec3 getColorOverLifetime( in float positionInTime, in vec3 color1, in vec3 color2, in vec3 color3, in vec3 color4 ) {",
          "    vec3 value = vec3( 0.0 );",
          "    value.x = getFloatOverLifetime( positionInTime, vec4( color1.x, color2.x, color3.x, color4.x ) );",
          "    value.y = getFloatOverLifetime( positionInTime, vec4( color1.y, color2.y, color3.y, color4.y ) );",
          "    value.z = getFloatOverLifetime( positionInTime, vec4( color1.z, color2.z, color3.z, color4.z ) );",
          "    return value;",
          "}",
          ""
        ],

        "paramFetchingFunctions": [
          "float getAlive() {",
          "   return params.x;",
          "}",

          "float getAge() {",
          "   return params.y;",
          "}",

          "float getMaxAge() {",
          "   return params.z;",
          "}",

          "float getWiggle() {",
          "   return params.w;",
          "}",
          ""
        ],
        "forceFetchingFunctions": [
          "vec4 getPosition( in float age ) {",
          "   return modelViewMatrix * vec4( position, 1.0 );",
          "}",

          "vec3 getVelocity( in float age ) {",
          "   return velocity * age;",
          "}",

          "vec3 getAcceleration( in float age ) {",
          "   return acceleration.xyz * age;",
          "}",
          ""
        ],

        "rotationFunctions": [
          "#ifdef SHOULD_ROTATE_PARTICLES",
          "   mat4 getRotationMatrix( in vec3 axis, in float angle) {",
          "       axis = normalize(axis);",
          "       float s = sin(angle);",
          "       float c = cos(angle);",
          "       float oc = 1.0 - c;",
          "",
          "       return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,",
          "                   oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,",
          "                   oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,",
          "                   0.0,                                0.0,                                0.0,                                1.0);",
          "   }",
          "",
          "   vec3 getRotation( in vec3 pos, in float positionInTime ) {",
          "      if( rotation.y == 0.0 ) {",
          "           return pos;",
          "      }",
          "",
          "      vec3 axis = unpackRotationAxis( rotation.x );",
          "      vec3 center = rotationCenter;",
          "      vec3 translated;",
          "      mat4 rotationMatrix;",

          "      float angle = 0.0;",
          "      angle += when_eq( rotation.z, 0.0 ) * rotation.y;",
          "      angle += when_gt( rotation.z, 0.0 ) * mix( 0.0, rotation.y, positionInTime );",
          "      translated = rotationCenter - pos;",
          "      rotationMatrix = getRotationMatrix( axis, angle );",
          "      return center - vec3( rotationMatrix * vec4( translated, 0.0 ) );",
          "   }",
          "#endif ",
          ""
        ],
        "rotateTexture": [
          "    vec2 vUv = vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y );",
          "",
          "    #ifdef SHOULD_ROTATE_TEXTURE",
          "       float x = gl_PointCoord.x - 0.5;",
          "       float y = 1.0 - gl_PointCoord.y - 0.5;",
          "       float c = cos( -vAngle );",
          "       float s = sin( -vAngle );",

          "       vUv = vec2( c * x + s * y + 0.5, c * y - s * x + 0.5 );",
          "    #endif ",
          "",
          "    #ifdef SHOULD_CALCULATE_SPRITE",
          "        float framesX = vSpriteSheet.x;",
          "        float framesY = vSpriteSheet.y;",
          "        float columnNorm = vSpriteSheet.z;",
          "        float rowNorm = vSpriteSheet.w;",

          "        vUv.x = gl_PointCoord.x * framesX + columnNorm;",
          "        vUv.y = 1.0 - (gl_PointCoord.y * framesY + rowNorm);",
          "    #endif ",

          "",
          "    vec4 rotatedTexture = texture2D( texture, vUv );",
          ""
        ]
      },
      "INSTANCING_CHUNKS":{

        "vx_view":[
          "precision highp float;",
          "uniform mat4 modelViewMatrix;",
          "uniform mat4 projectionMatrix;"
        ],
        "fx_view":[
          "precision highp float;"
        ],


        "vx_predictive_simulation":[
          "varying vec3 velocityOffset;",
          "varying vec3 offset;",
          "varying float size;",
          "attribute float time;",
          "attribute float duration;",
          "attribute vec3 vertexPosition;",
          "attribute vec4 offsetSize;",
          "attribute vec4 velocity;",
          "attribute vec4 acceleration;"
        ],

        "vx_data_texture":[
          "uniform sampler2D data_texture;",
          "attribute vec4 diffusors;",
          "attribute vec4 texelRowSelect;",
          "varying vec2 pixelSelector;",
          "varying vec4 sampledDataTexel;",

          "varying float rowColor;",
          "varying float rowSize;",
          "varying float rowDiffusion;",
          "varying float rowDrag;",
          "varying float progress;",
          "varying float pixelSizeSampler;",
          "varying float sampledSizeFactor;",
          "varying vec4  velocityDiffusion;",
          "varying vec4  accelerationDiffusion;",
          "varying float sillyRandom1;",
          "varying float sillyRandom2;",
          "varying float sillyRandom3;",
          "varying vec4 pixelColorSampler;"
        ],

        "vx_billboard":[
          "varying vec4 billboardFacing;"
        ],

        "vx_size":[
          "attribute float size;"
        ],

        "vx_spatial":[
          "attribute vec3 vertexPosition;",
          "attribute vec3 offset;"
        ],

        "vx_orientation_quat":[
          "attribute vec4 orientation;"
        ],

        "vx_uv":[
          "attribute vec2 uv;",
          "varying vec2 vUv;"
        ],


        "fx_uv":[
          "uniform sampler2D map;",
          "varying vec2 vUv;"
        ],

        "vx_uv_tiles":[
          "attribute vec2 tileindex;",
          "uniform vec2 tiles;",
          "varying vec2 tileOffset;"
        ],

        "fx_uv_tiles":[
          "varying vec2 tileOffset;"
        ],

        "vx_init":[
          "uniform float time;",
          "attribute vec2 uv;",
          "attribute vec3 translate;",
          "varying vec2 vUv;",
          "varying float vScale;",
          "attribute vec3 position;",
          "attribute float sizeFactor;"
        ],

        "fx_init":[
          "uniform sampler2D map;",
          "varying vec2 vUv;",
          "varying float vScale;",
          "vec3 HUEtoRGB(float H){",
          "H = mod(H,1.0);",
          "float R = abs(H * 6.0 - 3.0) - 1.0;",
          "float G = 2.0 - abs(H * 6.0 - 2.0);",
          "float B = 2.0 - abs(H * 6.0 - 4.0);",
          "return clamp(vec3(R,G,B),0.0,1.0);",
          "}",
          "vec3 HSLtoRGB(vec3 HSL){",
          "vec3 RGB = HUEtoRGB(HSL.x);",
          "float C = (1.0 - abs(2.0 * HSL.z - 1.0)) * HSL.y;",
          "return (RGB - 0.5) * C + HSL.z;",
          "}",
          ""
        ],
        "vx_attribute_vertexColor4":[
          "attribute vec4 vertexColor;",
          "varying vec4 vColor;"
        ],

        "vx_attribute_vertexColor":[
          "attribute vec3 vertexColor;",
          "attribute float vertexAlpha;",
          "varying vec4 vColor;"
        ],

        "fx_varying_vColor4":[
          "varying vec4 vColor;"
        ],
        "fx_attribute_vertexColor":[
          "varying vec4 vColor;"
        ],

        "fx_alphaTest":[
          "uniform float alphaTest;"
        ]
      }
    }
  }
]
