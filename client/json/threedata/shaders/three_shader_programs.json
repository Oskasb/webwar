[
  {
    "SHADER_PROGRAMS": {
      "LOAD_PROGRAM_INDEX":[
        "INSTANCING_PROGRAMS"
      ],
      "SPE_PROGRAMS":{
        "particleVertexMain":[
          "    highp float age = getAge();",
          "    highp float alive = getAlive();",
          "    highp float maxAge = getMaxAge();",
          "    highp float positionInTime = (age / maxAge);",
          "    highp float isAlive = when_gt( alive, 0.0 );",

          "    #ifdef SHOULD_WIGGLE_PARTICLES",
          "        float wiggleAmount = positionInTime * getWiggle();",
          "        float wiggleSin = isAlive * sin( wiggleAmount );",
          "        float wiggleCos = isAlive * cos( wiggleAmount );",
          "    #endif",

          "    vec3 vel = getVelocity( age );",
          "    vec3 accel = getAcceleration( age );",
          "    vec3 force = vec3( 0.0 );",
          "    vec3 pos = vec3( position );",

          "    float drag = 1.0 - (positionInTime * 0.5) * acceleration.w;",

          "    force += vel;",
          "    force *= drag;",
          "    force += accel * age;",
          "    pos += force;",

          "    #ifdef SHOULD_WIGGLE_PARTICLES",
          "        pos.x += wiggleSin;",
          "        pos.y += wiggleCos;",
          "        pos.z += wiggleSin;",
          "    #endif",

          "    #ifdef SHOULD_ROTATE_PARTICLES",
          "        pos = getRotation( pos, positionInTime );",
          "    #endif",

          "    vec4 mvPosition = modelViewMatrix * vec4( pos, 1.0 );",

          "    highp float pointSize = getFloatOverLifetime( positionInTime, size ) * isAlive;",

          "    #ifdef HAS_PERSPECTIVE",
          "        float perspective = scale / length( mvPosition.xyz );",
          "    #else",
          "        float perspective = 1.0;",
          "    #endif",

          "    float pointSizePerspective = pointSize * perspective;",


          "    #ifdef COLORIZE",
          "       vec3 c = isAlive * getColorOverLifetime(",
          "           positionInTime,",
          "           unpackColor( color.x ),",
          "           unpackColor( color.y ),",
          "           unpackColor( color.z ),",
          "           unpackColor( color.w )",
          "       );",
          "    #else",
          "       vec3 c = vec3(1.0);",
          "    #endif",

          "    float o = isAlive * getFloatOverLifetime( positionInTime, opacity );",

          "    vColor = vec4( c, o );",

          "    #ifdef SHOULD_ROTATE_TEXTURE",
          "        vAngle = isAlive * getFloatOverLifetime( positionInTime, angle );",
          "    #endif",
          "    #ifdef SHOULD_CALCULATE_SPRITE",
          "        float framesX = textureAnimation.x;",
          "        float framesY = textureAnimation.y;",
          "        float loopCount = textureAnimation.w;",
          "        float totalFrames = textureAnimation.z;",
          "        float frameNumber = mod( (positionInTime * loopCount) * totalFrames, totalFrames );",

          "        float column = floor(mod( frameNumber, framesX ));",
          "        float row = floor( (frameNumber - column) / framesX );",

          "        float columnNorm = column / framesX;",
          "        float rowNorm = row / framesY;",

          "        vSpriteSheet.x = 1.0 / framesX;",
          "        vSpriteSheet.y = 1.0 / framesY;",
          "        vSpriteSheet.z = columnNorm;",
          "        vSpriteSheet.w = rowNorm;",
          "    #endif",
          "    gl_PointSize = pointSizePerspective;",
          "    gl_Position = projectionMatrix * mvPosition;",
          ""
        ],
        "particleFragmentMain":[
          "    vec3 outgoingLight = vColor.xyz;",
          "    #ifdef ALPHATEST",
          "       if ( vColor.w < float(ALPHATEST) ) discard;",
          "    #endif",
          ""
        ]
      },
      "INSTANCING_PROGRAMS":{
        "vertexPositionMain":[
          "vec3 vPosition = vertexPosition;"
        ],

        "vertexSizeMain":[
          "vPosition = vPosition * size;"
        ],

        "vertexSpatialMain":[
          "vec3 vcV = cross(orientation.xyz, vPosition);",
          "vPosition = vcV * (2.0 * orientation.w) + (cross(orientation.xyz, vcV) * 2.0 + vPosition);"
        ],

        "vertexSpatialFinal":[
          "gl_Position = projectionMatrix * modelViewMatrix * vec4( offset + vPosition, 1.0 );"
        ],

        "vertexUvMain":[
          "vUv = uv;"
        ],

        "fragmentTxColorMain":[


          "gl_FragColor = texture2D(map, vUv);"
        ],

        "fragmentUvMain":[
          "gl_FragColor = texture2D(map, vUv);"
        ],

        "vertexUvTilesMain":[
          "vec2 tileScale = 1.0/tiles;",

          "vec2 tileOffset = vec2(tileindex.x * tileScale.x, (tiles.y-1.0 - tileindex.y) * tileScale.y);",
          "vec2 scaledUv = uv*tileScale;",

          "vUv = scaledUv + tileOffset;"
        ],

        "vertexColorFromAttribColor3Alpha1":[
          "vColor = vec4(vertexColor.x, vertexColor.y, vertexColor.z, vertexAlpha);"
        ],

        "vertexColorFromAttribColor4":[
          "vColor = vec4(vertexColor.x, vertexColor.y, vertexColor.z,  vertexColor.w);"
        ],


        "fragmentUvTilesMain":[
          "gl_FragColor = texture2D( map, vUv);"
        ],

        "fragmentColoredTextureMain":[
          "vec4 txColor = texture2D( map, vUv);"
        ],

        

        "fragmentBlendTxColorVertexColor":[
          "vec4 finalColor = txColor * vColor;"
        ],



        "fragmentAlphaTest":[
          "if (finalColor.a <= alphaTest) discard;"
        ],


        "fragmentVColorFinal":[
          "gl_FragColor = finalColor;"
        ],

        "particleVertexMain":[
          "vec4 mvPosition = modelViewMatrix * vec4( translate, 1.0 );",
          "vec3 trTime = vec3(translate.x + time, translate.y + time, translate.z + time);",
          "float scale = 1.0 + 0.1 * (sin( trTime.x * 2.1 ) + sin( trTime.y * 3.2 ) + sin( trTime.z * 4.3 ));",
          "vScale = scale;",
          "scale = scale * 2.0 + 2.0;",
          "mvPosition.xyz += position * scale * sizeFactor;",
          "vUv = uv;",
          "gl_Position = projectionMatrix * mvPosition;",
          ""
        ],
        "particleFragmentMain":[
          "vec4 diffuseColor = texture2D( map, vUv );",
          "gl_FragColor = vec4( diffuseColor.xyz * HSLtoRGB(vec3(vScale/5.0, 1.0, 0.5)), diffuseColor.w );",
          "if ( diffuseColor.w < 0.5 ) discard;",
          ""
        ],
        "vertexColor":[
          "vColor = customColor;"
        ],
        "fragmentColor":[
          "gl_FragColor = vec4( color * vColor, 1.0 );",
          "gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );"
        ]
      }
    }
  }
]
